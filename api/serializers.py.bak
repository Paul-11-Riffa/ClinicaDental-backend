from rest_framework import serializers
from .models import (
    Usuario, Paciente, Odontologo, Recepcionista,
    Horario, Tipodeconsulta, Estadodeconsulta, Consulta,
    Tipodeusuario,   # ← roles
    Historialclinico,  # ← NUEVO: HCE
    Consentimiento, # <-- NUEVO: Consentimiento
)
from rest_framework.validators import UniqueTogetherValidator

# --------- Usuarios / Pacientes ---------

class UsuarioMiniSerializer(serializers.ModelSerializer):
    class Meta:
        model = Usuario
        fields = ("codigo", "nombre", "apellido", "correoelectronico", "telefono")


class PacienteSerializer(serializers.ModelSerializer):
    # OneToOne a Usuario (solo lectura, anidado)
    codusuario = UsuarioMiniSerializer(read_only=True)

    class Meta:
        model = Paciente
        fields = "__all__"


# Versión mini de Paciente para anidar en otras respuestas
class PacienteMiniSerializer(serializers.ModelSerializer):
    codusuario = UsuarioMiniSerializer(read_only=True)

    class Meta:
        model = Paciente
        fields = ("codusuario", "carnetidentidad")


# --------- Minis para relaciones de Consulta ---------

class OdontologoMiniSerializer(serializers.ModelSerializer):
    codusuario = UsuarioMiniSerializer(read_only=True)
    codigo = serializers.IntegerField(source='codusuario.codigo', read_only=True)

    class Meta:
        model = Odontologo
        fields = ("codigo", "codusuario", "especialidad", "nromatricula")


class RecepcionistaMiniSerializer(serializers.ModelSerializer):
    codusuario = UsuarioMiniSerializer(read_only=True)

    class Meta:
        model = Recepcionista
        fields = ("codusuario",)


class HorarioSerializer(serializers.ModelSerializer):
    class Meta:
        model = Horario
        fields = ("id", "hora",)


class TipodeconsultaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Tipodeconsulta
        fields = ("id", "nombreconsulta")


class EstadodeconsultaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Estadodeconsulta
        fields = ("id", "estado")


# --------- Crear / Detalle / Actualizar Consulta ---------

class CreateConsultaSerializer(serializers.ModelSerializer):
    class Meta:
        model = Consulta
        fields = (
            "fecha",
            "codpaciente",
            "cododontologo",
            "idhorario",
            "idtipoconsulta",
            "idestadoconsulta",
            "codrecepcionista",
        )

    def validate(self, data):
        """
        Validar que no exista ya una consulta para el mismo odontólogo,
        en la misma fecha y horario.
        """
        if Consulta.objects.filter(
            cododontologo=data['cododontologo'],
            fecha=data['fecha'],
            idhorario=data['idhorario']
            # Opcional: Excluir citas canceladas si se permite re-agendar sobre ellas
            # ).exclude(idestadoconsulta__in=[3, 4]
        ).exists():
            raise serializers.ValidationError(
                "Este horario ya está reservado con el odontólogo seleccionado."
            )
        return data


# --- NUEVO: Serializador para Reprogramar Cita ---
class ReprogramarConsultaSerializer(serializers.Serializer):
    """
    Serializador para validar los datos al reprogramar una cita.
    """
    fecha = serializers.DateField()
    idhorario = serializers.PrimaryKeyRelatedField(queryset=Horario.objects.all())

    def validate(self, data):
        """
        Valida que el nuevo horario para reprogramar esté disponible.
        El 'cododontologo' se inyecta desde la vista.
        """
        from datetime import date

        consulta = self.context.get('consulta')
        if not consulta:
            # Este error no debería ocurrir si se usa correctamente desde la vista
            raise serializers.ValidationError("No se encontró la consulta a reprogramar.")

        # VALIDACIÓN 1: No permitir reprogramar citas vencidas
        if consulta.fecha < date.today():
            raise serializers.ValidationError(
                "No se puede reprogramar una cita que ya pasó de fecha. La cita debe ser cancelada."
            )

        # VALIDACIÓN 2: La nueva fecha debe ser futura
        if data['fecha'] < date.today():
            raise serializers.ValidationError(
                "No se puede reprogramar una cita a una fecha pasada."
            )

        cododontologo = consulta.cododontologo

        # VALIDACIÓN 3: Validar que el nuevo horario no esté ya ocupado por otra cita
        if Consulta.objects.filter(
            cododontologo=cododontologo,
            fecha=data['fecha'],
            idhorario=data['idhorario']
        ).exclude(pk=consulta.pk).exists(): # Excluimos la cita actual
            raise serializers.ValidationError(
                "El nuevo horario seleccionado no está disponible."
            )
        return data

# --------- Consulta ---------

class ConsultaSerializer(serializers.ModelSerializer):
    codpaciente = PacienteMiniSerializer(read_only=True)
    cododontologo = OdontologoMiniSerializer(read_only=True)
    codrecepcionista = RecepcionistaMiniSerializer(read_only=True)
    idhorario = HorarioSerializer(read_only=True)
    idtipoconsulta = TipodeconsultaSerializer(read_only=True)
    idestadoconsulta = EstadodeconsultaSerializer(read_only=True)

    class Meta:
        model = Consulta
        fields = "__all__"


class UpdateConsultaSerializer(serializers.ModelSerializer):
    """
    Serializador específico para actualizar solo el estado de una consulta.
    """
    class Meta:
        model = Consulta
        fields = ["idestadoconsulta"]


# --------- ADMIN: Roles y Usuarios (lista + cambio de rol) ---------

class TipodeusuarioSerializer(serializers.ModelSerializer):
    # 'identificacion' visible en la API, tomado del PK real 'id'
    identificacion = serializers.IntegerField(source="id", read_only=True)

    class Meta:
        model = Tipodeusuario
        fields = ("identificacion", "rol", "descripcion")


class UsuarioAdminSerializer(serializers.ModelSerializer):
    rol = serializers.CharField(source="idtipousuario.rol", read_only=True)
    idtipousuario = serializers.PrimaryKeyRelatedField(
        queryset=Tipodeusuario.objects.all(), required=False
    )

    class Meta:
        model = Usuario
        fields = (
            "codigo",
            "nombre",
            "apellido",
            "correoelectronico",
            "idtipousuario",
            "rol",
        )
    # 'codigo' viene de BD/negocio, lo dejamos de solo lectura si así lo manejan
        read_only_fields = ("codigo",)

    def update(self, instance, validated_data):
        new_role = validated_data.get("idtipousuario")
        if new_role and instance.idtipousuario_id == 1 and new_role.id != 1:
            remaining_admins = (
                Usuario.objects
                .filter(idtipousuario_id=1)
                .exclude(pk=instance.pk)
                .count()
            )
            if remaining_admins == 0:
                raise serializers.ValidationError(
                    "No puedes remover el último administrador del sistema."
                )
        return super().update(instance, validated_data)


class UserNotificationSettingsSerializer(serializers.ModelSerializer):
    """
    Serializer para actualizar únicamente las preferencias de notificación.
    """
    class Meta:
        model = Usuario
        fields = ['recibir_notificaciones']


# --------- PERFIL (GET/PATCH de la propia fila en `usuario`) ---------
class PacienteProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = Paciente
        fields = ('direccion', 'fechanacimiento', 'carnetidentidad')


class OdontologoProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = Odontologo
        fields = ('especialidad', 'experienciaProfesional', 'noMatricula')


class RecepcionistaProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = Recepcionista
        fields = ('habilidadesSoftware',)


# --- Serializer Principal para el Perfil del Usuario ---
class UsuarioMeSerializer(serializers.ModelSerializer):
    """
    Gestiona la lectura y actualización del perfil del usuario autenticado,
    incluyendo los campos específicos de su rol.
    """
    # Campo dinámico que mostrará el perfil correcto (paciente, odontologo, etc.)
    perfil = serializers.SerializerMethodField()

    class Meta:
        model = Usuario
        # Campos comunes que siempre se mostrarán
        fields = (
            'codigo', 'nombre', 'apellido', 'telefono',
            'correoelectronico', 'sexo', 'perfil'
        )
        read_only_fields = ('codigo', 'correoelectronico', 'perfil')

    def get_perfil(self, instance):
        """
        Esta función se ejecuta al LEER (GET) los datos.
        Devuelve un diccionario con los datos del perfil específico del usuario.
        """
        # El 'idtipousuario_id' viene de tu modelo Usuario y nos dice el rol.
        role_id = instance.idtipousuario_id

        if role_id == 2 and hasattr(instance, 'paciente'):  # 2 = Paciente
            return PacienteProfileSerializer(instance.paciente).data
        elif role_id == 4 and hasattr(instance, 'odontologo'):  # 4 = Odontologo
            return OdontologoProfileSerializer(instance.odontologo).data
        elif role_id == 3 and hasattr(instance, 'recepcionista'):  # 3 = Recepcionista
            return RecepcionistaProfileSerializer(instance.recepcionista).data

        return None  # Si no tiene un perfil específico

    def update(self, instance, validated_data):
        """
        Esta función se ejecuta al GUARDAR (PATCH/PUT) los datos.
        """
        # 1. Actualiza los campos comunes del modelo Usuario
        instance.nombre = validated_data.get('nombre', instance.nombre)
        instance.apellido = validated_data.get('apellido', instance.apellido)
        instance.telefono = validated_data.get('telefono', instance.telefono)
        instance.save()

        # 2. Revisa los datos que llegaron en la petición (`self.context['request'].data`)
        #    y actualiza el perfil correspondiente.
        request_data = self.context['request'].data
        role_id = instance.idtipousuario_id

        if role_id == 2 and hasattr(instance, 'paciente'):
            paciente_serializer = PacienteProfileSerializer(
                instance.paciente, data=request_data, partial=True
            )
            paciente_serializer.is_valid(raise_exception=True)
            paciente_serializer.save()

        elif role_id == 4 and hasattr(instance, 'odontologo'):
            odontologo_serializer = OdontologoProfileSerializer(
                instance.odontologo, data=request_data, partial=True
            )
            odontologo_serializer.is_valid(raise_exception=True)
            odontologo_serializer.save()

        elif role_id == 3 and hasattr(instance, 'recepcionista'):
            recepcionista_serializer = RecepcionistaProfileSerializer(
                instance.recepcionista, data=request_data, partial=True
            )
            recepcionista_serializer.is_valid(raise_exception=True)
            recepcionista_serializer.save()

        return instance

#para notificaciones
class NotificationPreferencesSerializer(serializers.ModelSerializer):
    """
    Serializer para gestionar las preferencias de notificaciones del usuario.
    """

    class Meta:
        model = Usuario
        fields = ['notificaciones_email', 'notificaciones_push']

    def update(self, instance, validated_data):
        instance.notificaciones_email = validated_data.get('notificaciones_email', instance.notificaciones_email)
        instance.notificaciones_push = validated_data.get('notificaciones_push', instance.notificaciones_push)
        instance.save()
        return instance


# =========================
#   NUEVO: Historias Clínicas (HCE)
# =========================
from django.utils import timezone
from django.db.models import Max

class HistorialclinicoCreateSerializer(serializers.ModelSerializer):
    """
    Crea una HCE (episodio) para un paciente.
    Regla anti-duplicado: mismo día + mismo motivo -> requiere forzar_nuevo_episodio=true
    """
    pacientecodigo = serializers.PrimaryKeyRelatedField(queryset=Paciente.objects.all())
    forzar_nuevo_episodio = serializers.BooleanField(write_only=True, required=False, default=False)

    class Meta:
        model = Historialclinico
        fields = [
            'pacientecodigo',
            'alergias', 'enfermedades', 'motivoconsulta', 'diagnostico',
            'forzar_nuevo_episodio',
        ]

    def validate(self, attrs):
        if not (attrs.get('motivoconsulta') or '').strip():
            raise serializers.ValidationError('El motivo de consulta es obligatorio.')
        return attrs

    def create(self, validated):
        paciente = validated['pacientecodigo']
        forzar = validated.pop('forzar_nuevo_episodio', False)

        # siguiente episodio para este paciente
        max_epi = Historialclinico.objects.filter(pacientecodigo=paciente)\
                                          .aggregate(Max('episodio'))['episodio__max'] or 0

        # posible duplicado en el día por mismo motivo
        hoy = timezone.localdate()
        dup = Historialclinico.objects.filter(
            pacientecodigo=paciente,
            motivoconsulta=(validated.get('motivoconsulta') or '').strip(),
            fecha__date=hoy
        ).first()

        if dup and not forzar:
            raise serializers.ValidationError({
                'duplicado': 'Ya existe una HCE hoy con el mismo motivo. Envíe forzar_nuevo_episodio=true para abrir un nuevo episodio.'
            })

        hce = Historialclinico.objects.create(
            episodio=max_epi + 1,
            **validated
        )
        return hce


class HistorialclinicoListSerializer(serializers.ModelSerializer):
    paciente_nombre = serializers.CharField(source='pacientecodigo.codusuario.nombre', read_only=True)
    paciente_apellido = serializers.CharField(source='pacientecodigo.codusuario.apellido', read_only=True)
    consentimientos = serializers.SerializerMethodField()

    class Meta:
        model = Historialclinico
        fields = [
            'id', 'pacientecodigo', 'paciente_nombre', 'paciente_apellido',
            'episodio', 'fecha',
            'alergias', 'enfermedades', 'motivoconsulta', 'diagnostico',
            'updated_at', 'consentimientos'
        ]
    
    def get_consentimientos(self, obj):
        """Obtiene los consentimientos asociados a este episodio del historial"""
        from .models_consent import Consentimiento
        # Buscamos consentimientos del mismo día del episodio
        consentimientos = Consentimiento.objects.filter(
            paciente=obj.pacientecodigo,
            fecha_firma__date=obj.fecha.date()
        ).order_by('-fecha_firma')
        
        # Usamos ConsentimientoSerializer pero con campos específicos para el historial
        return [{
            'id': c.id,
            'titulo': c.titulo,
            'firmado': c.firmado,
            'fecha_firma': c.fecha_firma,
            'validado': c.validado,
            'validado_por': c.validado_por.codusuario.nombre if c.validado_por else None,
            'fecha_validacion': c.fecha_validacion,
            'hash_documento': c.hash_documento
        } for c in consentimientos]

# =========================
#   NUEVO: Consentimiento Digital
# =========================
class ConsentimientoSerializer(serializers.ModelSerializer):
    """
    Serializador para crear y listar consentimientos digitales.
    El campo `paciente` se espera como un ID al crear.
    """
    # Campos de solo lectura para mostrar info útil en la API
    paciente_nombre = serializers.CharField(source='paciente.codusuario.nombre', read_only=True)
    paciente_apellido = serializers.CharField(source='paciente.codusuario.apellido', read_only=True)
    fecha_creacion_formateada = serializers.DateTimeField(source='fecha_creacion', format="%d/%m/%Y %H:%M", read_only=True)

    class Meta:
        model = Consentimiento
        fields = (
            'id',
            'paciente', 
            'consulta', 
            'plan_tratamiento',
            'titulo', 
            'texto_contenido',
            'firma_base64',
            # Campos de solo lectura
            'paciente_nombre',
            'paciente_apellido',
            'fecha_creacion',
            'fecha_creacion_formateada',
            'ip_creacion',
            'empresa',
        )
        # Campos que no se deben requerir en la entrada (POST/PUT)
        read_only_fields = (
            'id',
            'fecha_creacion',
            'ip_creacion',
            'empresa',
            'paciente_nombre',
            'paciente_apellido',
            'fecha_creacion_formateada',
        )

    def create(self, validated_data):
        request = self.context.get('request')
        if not request:
            raise serializers.ValidationError({
                "error": "No se pudo obtener el contexto de la petición",
                "detail": "El serializador requiere acceso al objeto request"
            })
        
        # Validar y asignar el tenant (empresa)
        if not hasattr(request, 'tenant') or not request.tenant:
            raise serializers.ValidationError({
                "error": "No se pudo determinar el tenant",
                "detail": "Se requiere un tenant válido para crear consentimientos",
                "debug_info": {
                    "user": str(request.user),
                    "path": request.path,
                    "method": request.method
                }
            })
        
        # Asignar la empresa explícitamente
        empresa = request.tenant
        if not empresa.id:
            raise serializers.ValidationError({
                "error": "Tenant inválido",
                "detail": "El tenant no tiene un ID válido"
            })
            
        validated_data['empresa_id'] = empresa.id
        
        # Extraer la IP del cliente
        x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
        if x_forwarded_for:
            ip = x_forwarded_for.split(',')[0]
        else:
            ip = request.META.get('REMOTE_ADDR')
        validated_data['ip_creacion'] = ip

        try:
            instance = super().create(validated_data)
            print(f"Consentimiento creado exitosamente: ID={instance.id}, empresa_id={instance.empresa_id}")
            return instance
        except Exception as e:
            print(f"Error al crear el consentimiento: {str(e)}")
            print(f"Datos validados: {validated_data}")
            raise

# api/serializers.py - Agregar al final del archivo existente

from .models import Bitacora


class BitacoraSerializer(serializers.ModelSerializer):
    usuario_nombre = serializers.SerializerMethodField()
    accion_display = serializers.CharField(source='get_accion_display', read_only=True)
    fecha_hora_formatted = serializers.SerializerMethodField()

    class Meta:
        model = Bitacora
        fields = [
            'id', 'accion', 'accion_display', 'descripcion',
            'fecha_hora', 'fecha_hora_formatted', 'usuario', 'usuario_nombre',
            'ip_address', 'user_agent', 'modelo_afectado', 'objeto_id',
            'datos_adicionales'
        ]
        read_only_fields = ['id', 'fecha_hora']

    def get_usuario_nombre(self, obj):
        if obj.usuario:
            return f"{obj.usuario.nombre} {obj.usuario.apellido}"
        return "Usuario anónimo"

    def get_fecha_hora_formatted(self, obj):
        return obj.fecha_hora.strftime('%d/%m/%Y %H:%M:%S')


# Función auxiliar para crear registros de bitácora manualmente
def crear_registro_bitacora(accion, usuario=None, ip_address='127.0.0.1', descripcion='',
                            modelo_afectado=None, objeto_id=None, datos_adicionales=None):
    """
    Función auxiliar para crear registros de bitácora desde las vistas
    """
    return Bitacora.objects.create(
        accion=accion,
        descripcion=descripcion,
        usuario=usuario,
        ip_address=ip_address,
        modelo_afectado=modelo_afectado,
        objeto_id=objeto_id,
        datos_adicionales=datos_adicionales or {}
    )
